#!/usr/bin/env bash

# NOTE: this script doesn't work as intended when backing up a Linux FS to an
# NTFS drive, thanks to permissions being incompatible. rsync detects all files
# as changed, then does a full sync every time!

# configuration options
SOURCE='/'
DAYS_TO_KEEP=365

# the directory used to notify that a system backup is happening
lock_dir="/tmp/backup.lock"
info_file="${lock_dir}/info"

# if the user requested the status of the backup, print the status and exit
if [[ "${1}" == "-s" ]] || [[ "${1}" == "--status" ]]; then
  if [ -e "${lock_dir}" ]; then
    # if the user supplied a custom string, print it
    custom_active_message="${2}"
    if [ ! -z "${custom_active_message}" ]; then
      echo "${custom_active_message}"
    fi
  else
    # notify that there's no backup in progress, printing any custom message
    custom_inactive_message="${3}"
    if [ ! -z "${custom_inactive_message}" ]; then
      echo "${custom_inactive_message}"
    fi
  fi

  # always exit with success
  exit 0
fi

# our only argument is the destination
DEST="$(realpath -q ${1})"

# exit if we're not running as root, since we'll need it to run the backup
if [[ ${EUID} -ne 0 ]]; then
  echo 'This script needs root privileges to run!'
  exit 1
fi

# exit if we can't grab our lock
if ! mkdir "${lock_dir}" &> /dev/null; then
  echo "Backup already in progress:"
  cat "${info_file}"
  echo "Exiting."
  exit 1
fi

# always remove the lock directory we just created on exit, no matter what.
# however, this is set after the lock to ensure that we don't spurriously remove
# another process's lock!
trap "rm -rf ${lock_dir}" INT QUIT TERM EXIT

# store some useful info about this backup
echo "start_date: $(date)" >> "${info_file}"
echo "pid: ${BASHPID}" >> "${info_file}"

# make sure the destination directory exists
mkdir -p "${DEST}"

# create a time-stamped directory for this backup
backup_dir="${DEST}/backup-$(date '+%Y-%m-%dT%H:%M:%S')"

# this link points to the most recent backup. it's used as a simple way to get
# the location of the most recent backup, as well as a way to chain the most
# recent backup to older ones via --link-dest. if this file doesn't already
# exist, rsync ignores the --link-dest option, conveniently enough.
current_link="${DEST}/current"

# start backing things up!
echo "Backing up '${SOURCE}' to '${backup_dir}'..."
echo

# use rsync and back everything up, telling it to be frugal with CPU and IO
nice -n19 ionice -c3 rsync \
  --link-dest="${current_link}" \
  \
  --itemize-changes \
  --human-readable \
  --recursive \
  --links \
  --perms \
  --times \
  --group \
  --owner \
  --devices \
  --specials \
  --executability \
  \
  --exclude '/home/*/.cache' \
  --exclude '/home/*/.thumbnails' \
  --include '/home' \
  --exclude '/tmp/*' \
  --exclude '/var/tmp/*' \
  --exclude '/var/log/journal/*' \
  --exclude '/dev/*' \
  --exclude '/proc/*' \
  --exclude '/sys/*' \
  --exclude '/mnt/*' \
  --exclude "${DEST}" \
  \
  "${SOURCE}" "${backup_dir}"

# re-write the 'current' link to point to the backup we just finished. we do
# this only once the backup is complete since we only want to mark actual,
# complete backups as the 'current' backup. if a backup is interrupted and we
# fail to update the symlink, new backups will simply use the symlink to a
# different backup instead of this one.
echo
echo "Marking '${backup_dir}' as the current backup..."
rm -f "${current_link}" && ln -s "${backup_dir}" "${current_link}"

# remove old backups
echo
echo "Removing old backups from '${DEST}'"

present="$(date +%s)"
for old_backup_dir in ${DEST}/backup-*; do
  # ignore non-directory files
  if [ ! -d "${old_backup_dir}" ]; then
    continue
  fi

  # pull the date (everything after the first '-') out of the directory name
  dirname="$(basename ${old_backup_dir} | cut -d '-' -f 2-)"

  # get the old date in UNIX time so we can calculate how many days old it is
  past="$(date -d ${dirname} +%s)"

  # bail if we couldn't get a date
  if [[ "$?" -ne "0" ]]; then
    echo "  ERROR: Couldn't parse date for '${old_backup_dir}'"
    continue
  fi

  # if the old backup directory is older than the cutoff, remove the folder.
  # since it will only contain hardlinks, it's safe to remove backups as the
  # hard links will always just point to the physical file on disk.
  if [[ "$(( (present - past) / (60 * 60 * 24) ))" -gt ${DAYS_TO_KEEP} ]]; then
    echo "  Removing '${old_backup_dir}'..."
    rm -rf "${old_backup_dir}"
  fi
done

echo "Done removing old backups."

echo
echo "Backup complete!"
